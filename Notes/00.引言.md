[TOC]

<style>
img{
    width: 80%;
    padding-left: 10%;
}
</style>

## 第一章 引言

-   [EffectiveJava3.0中文版在线阅读](https://sjsdfg.github.io/effective-java-3rd-chinese) 加群有pdf版
-   [EffectiveJava3.0源代码](https://github.com/jbloch/effective-java-3e-source-code)
-   本书目标：更有效地使用Java编程语言及其基本类库java.lang、java.util和java.io，以及子包java.util.concurrent和java.util.function等。
-   一共90个条目，每个条目讨论一条规则。每个条目都有一定程度的独立性，条目相互之间经常交叉引用
    ![](./images/1-1.png)
-   包含许多用来说明 **设计模式（Design Pattern）和习惯用法（Idiom）** 的代码示例，也包含有一个或多个应该在实践中 **避免** 的程序示例-“反模式”（Antipattern），在注释中清楚地标注为"/Never do this！"。
-   本书不是针对初学者的
-   本书中使用的术语“组件"（Component），是指任何可重用的软件元素，从单个方法，到包含多个包的复杂框架，都可以是一个组件
    -   清晰性和简洁性最为重要：组件的用户永远也不应该被其行为所迷惑
    -   代码应该被重用，而不是被拷贝。组件之间的依赖性应该尽可能地降到最小。错误应该尽早被检测出来，最好是在编译时就发现并解决
-   本书大部分内容都不是讨论性能的，而是关心如何编写出清晰、正确、可用、健壮、灵活和可维护的程序来
-   [本书的Web站点](http://joshbloch.com/effectivejava)提供了每个示例的完整版本
-   本书采用的大部分技术术语都与《The Java Language Specification，Java SE 8 Edition》[JLS]相同
-   章节简介
    > 第1章为引言。
    > 第2章阐述何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清除动作。
    > 第3章阐述对于所有对象都通用的方法，你会从中获知对equals，hashCode，tostring，clone，finalize以及Comparable.compareTo方法相当深人的分析，从而避免今后在这些问题上再次犯错
    > 第4章阐述作为Java程序设计语言的核心以及Java语言的基本抽象单元（类和接口）在使用上的一些指导原则，帮助你更好地利用这些元素，设计出更加有用、健壮和灵活的类与接口。
    > 第5章和第6章中分别阐述在Java 1.5发行版本中新增加的泛型（Generic）以及枚举Enum）和注解（Annotation）的最佳实践，教你如何最大限度地享有这些优势，并使整个过程尽可能地简单化。
    > 第7章专门讨论在Java 8中新增的函数接口（Functional Interface），Lambda表达式和方法引用（Method Reference），使创建函数对象（Function Object）变得更加容易。接着探讨为处理数据元素的序列提供了类库级别支持的Stream API，以及如何最佳地利用这些机制。
    > 第8章讨论方法设计的几个方面：如何处理参数和返回值，如何设计方法签名，如何为方法编写文档，从而使方法设计在可用性、健壮性和灵活性上有进一步的提升。
    > 第9章主要讨论Java语言的具体细节，讨论了局部变量的处理、控制结构、类库的使用、各种数据类型的用法，以及两种不是由语言本身提供的机制（Reffection 和Native Method，反射机制和本地方法）的用法，并讨论了优化和命名惯例。
    > 第10章阐述如何充分发挥异常的优点来提高程序的可读性、可靠性和可维护性，以及减少异常使用不当所带来的负面影响，并提供了一些关于有效使用异常的指导原则第11章阐述如何帮助你编写出清晰、正确、文档组织良好的并发程序，比如如何避免过度同步，优先采用Executor Framework、并发集合（Concurrent Collection）同步器（Synchronizer），以及是否需要依赖于线程调度器等。
    > 第12章阐述序列化方面的技术，并且有一项值得特别提及的特性，就是序列化代理（Serialization Proxy）模3助你避免对象序列化的许多缺陷

## 📚 高效 Java 第三版目录

### Chapter 2. Creating and Destroying Objects

-   [01. 考虑使用静态工厂方法替代构造方法](./01.%20考虑使用静态工厂方法替代构造方法.md)
-   [02. 当构造方法参数过多时使用builder模式](./02.%20当构造方法参数过多时使用builder模式.md)
-   [03. 使用私有构造方法或枚类实现Singleton属性](./03.%20使用私有构造方法或枚类实现Singleton属性.md)
-   [04. 使用私有构造方法执行非实例化](./04.%20使用私有构造方法执行非实例化.md)
-   [05. 依赖注入优于硬连接资源(hardwiring resources)](./05.%20依赖注入优于硬连接资源(hardwiring%20resources).md)
-   [06. 避免创建不必要的对象](./06.%20避免创建不必要的对象.md)
-   [07. 消除过期的对象引用](./07.%20消除过期的对象引用.md)
-   [08. 避免使用Finalizer和Cleaner机制](./08.%20避免使用Finalizer和Cleaner机制.md)

### Chapter 3. Methods Common to All Objects

-   [09. 使用try-with-resources语句替代try-finally语句](./09.%20使用try-with-resources语句替代try-finally语句.md)
-   [10. 重写equals方法时遵守通用约定](./10.%20重写equals方法时遵守通用约定.md)
-   [11. 重写equals方法时同时也要重写hashcode方法](./11.%20重写equals方法时同时也要重写hashcode方法.md)
-   [12. 始终重写 toString 方法](./12.%20始终重写%20toString%20方法.md)
-   [13. 谨慎地重写 clone 方法](./13.%20谨慎地重写%20clone%20方法.md)
-   [14. 考虑实现Comparable接口](./14.%20考虑实现Comparable接口.md)

### Chapter 4. Classes and Interfaces

-   [15. 使类和成员的可访问性最小化](./15.%20使类和成员的可访问性最小化.md)
-   [16. 在公共类中使用访问方法而不是公共属性](./16.%20在公共类中使用访问方法而不是公共属性.md)
-   [17. 最小化可变性](./17.%20最小化可变性.md)
-   [18. 组合优于继承](./18.%20组合优于继承.md)
-   [19. 要么设计继承并提供文档说明，要么禁用继承](./19.%20要么设计继承并提供文档说明，要么禁用继承.md)
-   [20. 接口优于抽象类](./20.%20接口优于抽象类.md)
-   [21. 为后代设计接口](./21.%20为后代设计接口.md)
-   [22. 接口仅用来定义类型](./22.%20接口仅用来定义类型.md)
-   [23. 类层次结构优于标签类](./23.%20类层次结构优于标签类.md)
-   [24. 支持使用静态成员类而不是非静态类](./24.%20支持使用静态成员类而不是非静态类.md)
-   [25. 将源文件限制为单个顶级类](./25.%20将源文件限制为单个顶级类.md)

### Chapter 5. Generics

-   [26. 不要使用原始类型](./26.%20不要使用原始类型.md)
-   [27. 消除非检查警告](./27.%20消除非检查警告.md)
-   [28. 列表优于数组](./28.%20列表优于数组.md)
-   [29. 优先考虑泛型](./29.%20优先考虑泛型.md)
-   [30. 优先使用泛型方法](./30.%20优先使用泛型方法.md)
-   [31. 使用限定通配符来增加API的灵活性](./31.%20使用限定通配符来增加API的灵活性.md)
-   [32. 合理地结合泛型和可变参数](./32.%20合理地结合泛型和可变参数.md)
-   [33. 优先考虑类型安全的异构容器](./33.%20优先考虑类型安全的异构容器.md)

### Chapter 6. Enums and Annotations

-   [34. 使用枚举类型替代整型常量](./34.%20使用枚举类型替代整型常量.md)
-   [35. 使用实例属性替代序数](./35.%20使用实例属性替代序数.md)
-   [36. 使用EnumSet替代位属性](./36.%20使用EnumSet替代位属性.md)
-   [37. 使用EnumMap替代序数索引](./37.%20使用EnumMap替代序数索引.md)
-   [38. 使用接口模拟可扩展的枚举](./38.%20使用接口模拟可扩展的枚举.md)
-   [39. 注解优于命名模式](./39.%20注解优于命名模式.md)
-   [40. 始终使用Override注解](./40.%20始终使用Override注解.md)
-   [41. 使用标记接口定义类型](./41.%20使用标记接口定义类型.md)

### Chapter 7. Lambdas and Streams

-   [42. lambda表达式优于匿名类](./42.%20lambda表达式优于匿名类.md)
-   [43. 方法引用优于lambda表达式](./43.%20方法引用优于lambda表达式.md)
-   [44. 优先使用标准的函数式接口](./44.%20优先使用标准的函数式接口.md)
-   [45. 明智审慎地使用Stream](./45.%20明智审慎地使用Stream.md)
-   [46. 优先考虑流中无副作用的函数](./46.%20优先考虑流中无副作用的函数.md)
-   [47. 优先使用Collection而不是Stream来作为方法的返回类型](./47.%20优先使用Collection而不是Stream来作为方法的返回类型.md)
-   [48. 谨慎使用流并行](./48.%20谨慎使用流并行.md)

### Chapter 8. Methods

-   [49. 检查参数有效性](./49.%20检查参数有效性.md)
-   [50. 必要时进行防御性拷贝](./50.%20必要时进行防御性拷贝.md)
-   [51. 仔细设计方法签名](./51.%20仔细设计方法签名.md)
-   [52. 明智审慎地使用重载](./52.%20明智审慎地使用重载.md)
-   [53. 明智审慎地使用可变参数](./53.%20明智审慎地使用可变参数.md)
-   [54. 返回空的数组或集合，不要返回 null](./54.%20返回空的数组或集合，不要返回%20null.md)
-   [55. 明智审慎地返回 Optional](./55.%20明智审慎地返回%20Optional.md)
-   [56. 为所有已公开的 API 元素编写文档注释](./56.%20为所有已公开的%20API%20元素编写文档注释.md)

### Chapter 9. General Programming

-   [57. 最小化局部变量的作用域](./57.%20最小化局部变量的作用域.md)
-   [58. for-each 循环优于传统 for 循环](./58.%20for-each%20循环优于传统%20for%20循环.md)
-   [59. 了解并使用库](./59.%20了解并使用库.md)
-   [60. 若需要精确答案就应避免使用 float 和 double 类型](./60.%20若需要精确答案就应避免使用%20float%20和%20double%20类型.md)
-   [61. 基本数据类型优于包装类](./61.%20基本数据类型优于包装类.md)
-   [62. 当使用其他类型更合适时应避免使用字符串](./62.%20当使用其他类型更合适时应避免使用字符串.md)
-   [63. 当心字符串连接引起的性能问题](./63.%20当心字符串连接引起的性能问题.md)
-   [64. 通过接口引用对象](./64.%20通过接口引用对象.md)
-   [65. 接口优于反射](./65.%20接口优于反射.md)
-   [66. 明智审慎地本地方法](./66.%20明智审慎地本地方法.md)
-   [67. 明智审慎地进行优化](./67.%20明智审慎地进行优化.md)
-   [68. 遵守被广泛认可的命名约定](./68.%20遵守被广泛认可的命名约定.md)

### Chapter 10. Exceptions

-   [69. 只针对异常的情况下才使用异常](./69.%20只针对异常的情况下才使用异常.md)
-   [70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常](./70.%20对可恢复的情况使用受检异常，对编程错误使用运行时异常.md)
-   [71. 避免不必要的使用受检异常](./71.%20避免不必要的使用受检异常.md)
-   [72. 优先使用标准的异常](./72.%20优先使用标准的异常.md)
-   [73. 抛出与抽象对应的异常](./73.%20抛出与抽象对应的异常.md)
-   [74. 每个方法抛出的异常都需要创建文档](./74.%20每个方法抛出的异常都需要创建文档.md)
-   [75. 在细节消息中包含失败一捕获信息](./75.%20在细节消息中包含失败一捕获信息.md)
-   [76. 保持失败原子性](./76.%20保持失败原子性.md)
-   [77. 不要忽略异常](./77.%20不要忽略异常.md)

### Chapter 11. Concurrency

-   [78. 同步访问共享的可变数据](./78.%20同步访问共享的可变数据.md)
-   [79. 避免过度同步](./79.%20避免过度同步.md)
-   [80. executor 、task 和 stream 优先于线程](./80.%20executor%20、task%20和%20stream%20优先于线程.md)
-   [81. 并发工具优于 wait 和 notify](./81.%20并发工具优于%20wait%20和%20notify.md)
-   [82. 文档应包含线程安全属性](./82.%20文档应包含线程安全属性.md)
-   [83. 明智审慎的使用延迟初始化](./83.%20明智审慎的使用延迟初始化.md)
-   [84. 不要依赖线程调度器](./84.%20不要依赖线程调度器.md)

### Chapter 12. Serialization

-   [85. 优先选择 Java 序列化的替代方案](./85.%20优先选择%20Java%20序列化的替代方案.md)
-   [86. 非常谨慎地实现 Serializable](./86.%20非常谨慎地实现%20Serializable.md)
-   [87. 考虑使用自定义的序列化形式](./87.%20考虑使用自定义的序列化形式.md)
-   [88. 保护性的编写 readObject 方法](./88.%20保护性的编写%20readObject%20方法.md)
-   [89. 对于实例控制，枚举类型优于 readResolve](./89.%20对于实例控制，枚举类型优于%20readResolve.md)
-   [90. 考虑用序列化代理代替序列化实例](./90.%20考虑用序列化代理代替序列化实例.md)
